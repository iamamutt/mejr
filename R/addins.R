# rfmt --------------------------------------------------------------------

g_fmt_opts <- function(compact = FALSE) {
  # backup = Backup source 'FILE' to 'FILE.bak' before formatting
  # margin0 = Position of the first (soft) right margin
  # margin1 = Position of the second margin
  # cost0 = Cost (per character) beyond margin 0
  # cost1 = Cost (per character) beyond margin 1
  # costb = Cost per each line break
  # indent = Number of spaces for each indent
  # adj.comment = Multiply line break cost in inline comments
  # adj.flow = Multiply line break cost in control flow constructs
  # adj.call = Multiply line break cost in function calls
  # adj.arg = Multiply line break cost in argument expressions
  # cpack = Cost used to pack elements in justified layouts
  # force.brace = Ensure that control flow constructs have braces
  # space.arg.eq = Ensure spaces around equals signs in arguments
  # quiet = Suppress all diagnostic messages

  hard_margin <- getOption("mejr.rfmt.cols")

  soft_margin <- as.integer(round(hard_margin * 0.75))

  if (compact) {
    # list(
    # backup = FALSE,
    # margin0 = 8,
    # margin1 = hard_margin,
    # cost0 = 100,
    # cost1 = 200,
    # costb = 1e-5,
    # indent = 2,
    # adj.comment = 100,
    # adj.flow = 100,
    # adj.call = 100,
    # adj.arg = 100,
    # cpack = 1e-5,
    # force.brace = TRUE,
    # space.arg.eq = TRUE,
    # quiet = TRUE
    # )
    list(
      backup = FALSE, margin0 = soft_margin, margin1 = hard_margin, cost0 = 10,
      cost1 = 200, costb = 100, indent = 4, adj.comment = 100,
      adj.flow = 100, adj.call = 100, adj.arg = .1, cpack = .0001,
      force.brace = FALSE, space.arg.eq = TRUE, quiet = TRUE)
  } else {
    list(
      backup = FALSE, margin0 = soft_margin, margin1 = hard_margin,
      cost0 = 10 / (hard_margin - soft_margin), cost1 = 100,
      costb = 1000, indent = 2, adj.comment = 100,
      adj.flow = .15, adj.call = .1, adj.arg = .05, cpack = 1e-8,
      force.brace = TRUE, space.arg.eq = TRUE, quiet = TRUE)
  }
}

g_fmt_text <- function(filename, code = NULL,
                       win_cygwin = getOption("mejr.cygwin"),
                       opts = g_fmt_opts(getOption("mejr.rfmt.compact"))) {
  rfmt_url <- "https://github.com/google/rfmt.git"
  require_pkg("rfmt", paste0('devtools::install_git("', rfmt_url, '")'))

  write_lines <- FALSE
  if (is.null(code)) {
    if (!file.exists(filename)) {
      warning("File does not exist:", filename)
      return(NULL)
    }
    write_lines <- TRUE
    code <- readLines(filename)
  }

  os <- Sys.info()["sysname"]
  py_path <- Sys.getenv("PYTHONPATH")
  msg <- paste0("\nReformatting selection with pkg \"rfmt\"\n")

  if (write_lines) {
    file_msg <- paste0("file=", basename(filename), ", ")
  } else {
    file_msg <- "Selection, "
  }

  msg <- paste0(msg, file_msg, "OS=", os, ", Python=")

  # format text with rfmt given OS type
  formatted_text <- switch(tolower(os),
    windows = {
      # using the argument win_cygwin='C:/cygwin64' assumes PYTHONPATH is also
      # set to exe directory for python 2.7
      cyg_root <- if (isTRUE(nzchar(win_cygwin))) {
        win_cygwin
      } else {
        Sys.getenv("CYGWINPATH")
      }

      python_path <- normalizePath(
        file.path(cyg_root, "bin", "python2.7.exe"),
        winslash = "/", mustWork = FALSE
      )

      if (file.exists(python_path)) {
        msg <- paste0(msg, python_path)
        rfmt_stupid_old_python_windows_fix(
          code, opts,
          python_path = python_path
        )
      } else {
        NULL
      }
    },
    darwin = {
      msg <- paste0(msg, py_path)
      rfmt::rfmt(text = code, opts = opts)
    },
    linux = {
      linux_py <- "/usr/bin/python2"
      if (file.exists(linux_py)) {
        msg <- paste0(msg, linux_py)
        rfmt::rfmt(text = code, opts = opts)
      } else {
        NULL
      }
    },
    NULL)

  if (length(formatted_text) < 1) {
    formatted_text <- NULL
  }

  # try python path
  if (is.null(formatted_text) && nzchar(py_path)) {
    msg <- paste0(msg, py_path)
    formatted_text <- rfmt::rfmt(text = code, opts = opts)
  }

  message(msg)

  if (is.null(formatted_text)) {
    warning(
      "Formatting was not completed, ",
      "python not found or returned an error.\n",
      "Try setting the PYTHONPATH or CYGWINPATH",
      " environment variables, or placing ", "them in your .Rprofile.",
      "\nExample: ", "Sys.setenv(CYGWINPATH = \"C:/cygwin64\")")
    return(NULL)
  }

  if (write_lines) {
    enc::write_lines_enc(formatted_text, filename)
    return(NULL)
  }

  formatted_text
}

# need python 2.7 for windows rfmt
rfmt_stupid_old_python_windows_fix <- function(text, opts, python_path) {
  has_text <- nzchar(text)
  if (length(has_text) == 0 || !any(has_text)) {
    return()
  }

  old_path <- Sys.getenv("PYTHONPATH")
  Sys.setenv(PYTHONPATH = python_path)
  on.exit(Sys.setenv(PYTHONPATH = old_path))

  junk_file <- tempfile("rfmt")
  writeLines(text, junk_file)
  on.exit(unlink(junk_file), add = TRUE)

  py_script <- system.file("python", "rfmt.py", package = "rfmt")
  py_args <- c(
    py_script,
    sprintf(
      "--%s=%s", gsub(".", "_", names(opts), fixed = TRUE),
      unlist(opts)), junk_file)

  err <- system2(command = python_path, args = py_args, stderr = TRUE)
  if (any(nzchar(err))) {
    message(paste0(err, collapse = "\n"))
    cat("\n")
  }

  readLines(junk_file)
}

# styler ------------------------------------------------------------------

stylr_is_call_with_arg_line_break <- function(pd) {
  pd$terminal & pd$token == "'('" & pd$token_before == "SYMBOL_FUNCTION_CALL" &
    pd$newlines > 0 & pd$token_after != "COMMENT"
}

stylr_is_lonely_end_paren <- function(pd) {
  pd$token == "')'" & pd$terminal &
    pd$lag_newlines > 0 & pd$token_before != "COMMENT"
}

styler_transformers <- function() {
  m_spacing <- styler::tidyverse_math_token_spacing()
  reindent <- styler::tidyverse_reindention()
  reindent$indention <- 2
  reindent$comments_only <- TRUE

  fun <- styler::tidyverse_style(
    reindention = reindent, math_token_spacing = m_spacing,
    start_comments_with_one_space = TRUE
  )

  fun$line_break <- c(
    fun$line_break,
    list(
      remove_line_break_before_function_opening = function(pd) {
        rm_break <- (pd$token == "FUNCTION") &
          (pd$token_after == "'('") & (dplyr::lead(pd$newlines) == 1)
        pd$newlines[dplyr::lag(rm_break)] <- 0L
        pd$lag_newlines[dplyr::lag(rm_break, 2)] <- 0L
        pd
      },
      remove_lonely_ending_parenthesis = function(pd) {
        if (!any(stylr_is_call_with_arg_line_break(pd))) {
          rm_break <- stylr_is_lonely_end_paren(pd)
          pd$newlines[dplyr::lead(rm_break)] <- 0L
          pd$lag_newlines[rm_break] <- 0L
        }
        pd
      },
      ensure_newline_special_pipe = function(pd) {
        pipes <- pd$token == "SPECIAL-PIPE"
        if (any(pipes)) {
          pd$newlines[pipes] <- 1L
          pd$lag_newlines[dplyr::lag(pipes)] <- 1L
        }
        pd
      })
  )

  fun
}

stylr_fmt_txt <- function(filename, code = NULL) {
  require_pkg("styler")
  require_pkg("dplyr")

  if (is.null(code)) {
    if (!file.exists(filename)) {
      warning("File does not exist:", filename)
      return(NULL)
    }
    styler::style_file(filename,
      style = NULL,
      transformers = styler_transformers())
    return(NULL)
  } else {
    styler::style_text(code, style = NULL, transformers = styler_transformers())
  }
}

# addins ------------------------------------------------------------------

# Reformat a block of code using rfmt. Map to keyboard shortcut.
rfmtSelectionAddin <- function() {
  require_pkg("rstudioapi")

  # extract selected text using RStudio API
  text <- rstudioapi::getActiveDocumentContext()$selection[[1]]$text
  formatted_text <- rfmt_code(
    filename = NULL, code = text,
    use_rfmt = TRUE, use_styler = FALSE)
  if (!is.null(formatted_text)) {
    rstudioapi::insertText(text = paste(formatted_text, collapse = "\n"))
  }
  invisible()
}

stylerSelectionAddin <- function() {
  require_pkg("rstudioapi")

  # extract selected text using RStudio API
  text <- rstudioapi::getActiveDocumentContext()$selection[[1]]$text
  formatted_text <- rfmt_code(
    filename = NULL, code = text,
    use_rfmt = FALSE, use_styler = TRUE)
  if (!is.null(formatted_text)) {
    rstudioapi::insertText(text = paste(formatted_text, collapse = "\n"))
  }
  invisible()
}

# Reformat a block of code using formatR. Map to keyboard shortcut.
tidySelectionAddin <- function() {
  require_pkg("rstudioapi")
  require_pkg("formatR")
  context <- rstudioapi::getActiveDocumentContext()
  text_selection <- context$selection[[1]]$text
  if (nzchar(text_selection)) {
    formatted <- formatR::tidy_source(
      text = text_selection, output = FALSE, comment = TRUE,
      blank = TRUE, arrow = FALSE, indent = 2L, brace.newline = FALSE,
      width.cutoff = getOption("mejr.rfmt.cols")
    )
    formatted <- pipe_newline(formatted)
    rstudioapi::insertText(text = paste(formatted, collapse = "\n"))
  }
  invisible()
}

#' Split an Rmarkdown chunk into two at cursor
splitMarkdownChunk <- function() {
  require_pkg("rstudioapi")
  context <- rstudioapi::getActiveDocumentContext()
  cursor_pos <- context$selection[[1]]$range$end
  rstudioapi::setCursorPosition(c(cursor_pos[1], 1), id = context$id)
  rstudioapi::insertText(text = "```\n\n```{r}\n")
  rstudioapi::setCursorPosition(c(cursor_pos[1] + 3, 1), id = context$id)
  invisible()
}


viewSelectedData <- function() {
  # x <- data.table(rnorm(100))
  require_pkg("rstudioapi")
  context <- rstudioapi::getActiveDocumentContext()
  text <- context$selection[[1]]$text
  obj <- regmatches(text, regexpr("^\\s*[\\w\\d\\.]*[^\\(\\[\\$<]", text, perl = TRUE))
  obj <- stringr::str_trim(obj)

  if (length(obj) < 1 || !nzchar(obj)) {
    message("selected function not found.")
    return(invisible())
  }

  view_data(get(obj))
  invisible()
}

# misc --------------------------------------------------------------------

rfmt_code <- function(filename, code = NULL,
                      use_rfmt = getOption("mejr.use.rfmt"),
                      use_styler = getOption("mejr.use.styler")) {
  if (!use_rfmt && !use_styler) {
    return(invisible(NULL))
  }

  if (use_rfmt) {
    if (!is.null(code)) {
      filename <- NULL
    }
    code <- g_fmt_text(filename, code)
  }

  if (use_styler) {
    if (!is.null(code)) {
      filename <- NULL
    }
    code <- stylr_fmt_txt(filename, code)
  }

  code
}


#' @export
rfmt_dir <- function(root = ".") {
  r_files <- list.files(root,
    pattern = "\\.[Rr]$", all.files = FALSE,
    full.names = TRUE, recursive = TRUE)

  invisible(lapply(
    r_files,
    function(f) {
      rfmt_code(f)
    }))
}

pipe_newline <- function(x) {
  gsub("((?<=%>%)\\s)(?<!%>%$)", "\n", x, perl = TRUE)
}

# debug styler nest
.get_pd <- function(x = "dt %>% .[, N]%>%.[]%>%.[]%>%\n.[,\n.(\n.N)]") {
  library(magrittr)
  library(styler)
  library(dplyr)
  pd <- styler:::compute_parse_data_nested(x) %>%
    styler:::pre_visit(c(default_style_guide_attributes))
  pd$child[[1]]
}


#' View a data object with ggvis
#' @export
#' @examples
#' view_data(iris, -1)
view_data <- function(x,
                      n_rows = getOption("mejr.viewdata.nrows"),
                      page_size = getOption("mejr.viewdata.pagesize"),
                      page_height = getOption("mejr.viewdata.height"),
                      subset_fun = head) {
  require_pkg("googleVis")

  if (!inherits(x, "data.frame")) {
    return(invisible())
  }

  if (is.null(n_rows) || !is.numeric(n_rows)) {
    n_rows <- 1000L
  }

  if (length(n_rows) > 1L) {
    n_rows <- n_rows[n_rows > 0 & n_rows < nrow(x)]
    subset_fun <- function(x, i)
      x[i, ]
  }

  mejr_gvis_data <- match.fun(subset_fun)(x, n_rows)

  gtbl <- googleVis::gvisTable(
    mejr_gvis_data,
    options = list(
      page = "enable",
      height = page_height,
      width = "100%",
      pageSize = page_size,
      showRowNumber = TRUE
    ),
    chartid = "mejrView"
  )
  # options("googleVis.viewer"=NULL)
  # tmp <- tempfile()
  # dir.create(tmp)
  # html_file <- file.path(tmp, "index.html")
  # plot(gtbl, browser = rstudioapi::viewer)
  plot(gtbl)

  invisible()
}
